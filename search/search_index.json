{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Warp FastApi Documentation","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Warp-FastApi is a versatile Python library that serves as your navigational beacon through the intricate cosmos of FastAPI development. The library's core feature is the generation of well-structured, efficient code tailored to FastAPI, SQLAlchemy, and Pydantic. This means you can focus on crafting your application's unique logic, secure in the knowledge that the foundational code is expertly generated. Begin your FastAPI project with Warp-FastApi, where exploration and efficiency converge.</p>"},{"location":"#installation","title":"Installation","text":"<p>Begin your journey by installing Warp-FastApi using pip:</p> <pre><code>pip install warp-fastapi\n</code></pre>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Prepare for liftoff into the Warp-FastApi universe by following these simple steps:</p>"},{"location":"#beam-up-your-crew","title":"Beam Up Your Crew:","text":"<p>Assemble the core components of Warp-FastApi.</p> <pre><code>from warp_fastapi import AppObject, Attribute, AppProject\nfrom warp_fastapi.sqlalch_types import string_type, int_type, date_only_type\nfrom warp_fastapi.relationships import one_to_many, one_to_one, many_to_many, many_to_one\nfrom warp_fastapi.create_project import ProjectCreator\n</code></pre>"},{"location":"#warp-define-attributes","title":"Warp-Define Attributes:","text":"<pre><code># Engage attributes\na1 = Attribute(\"planet_name\", string_type)\na2 = Attribute(\"distance\", int_type)\nname = Attribute(\"ship_name\", string_type)\n</code></pre> <p>Define attributes with the precision of a star cartographer \u2013 each attribute corresponds to a specific celestial aspect. For more attribute types, refer to the SQL Types and Types documentation.</p>"},{"location":"#launch-your-app-spaceships","title":"Launch Your App Spaceships:","text":"<pre><code># Launch app spaceships\nplanet = AppObject(\"planet\", a1, a2)\nstarship = AppObject(\"starship\", name)\n</code></pre> <p>Initiate AppObjects, the very vessels of your application \u2013 give them designations, program their functional cores (attributes), and propel them into the coding cosmos!</p> <p>You can also establish an AppObject with attributes directly:</p> <pre><code>alien = AppObject(\"alien\", \n                Attribute(\"name\", string_type), \n                Attribute(\"species\", string_type), \n                Attribute(\"status\", string_type, optional=True))\ngadget = AppObject(\"gadget\", \n                Attribute(\"name\", string_type))\n</code></pre> <p>And don't forget to pack the optional \"status\" attribute for those unpredictable extraterrestrial encounters.</p>"},{"location":"#navigate-the-star-systems-add-starship-relations","title":"Navigate the Star Systems \u2013 Add Starship Relations:","text":"<pre><code>planet.add_relationship(starship, one_to_many, \"inhabited_by\", \"planet\")\nstarship.add_relationship(alien, one_to_many, \"crew\", \"starship\")\n</code></pre> <p>Much like celestial systems gravitate towards one another, your app objects require meaningful connections. Forge these connections by signaling the objects, inputting coordinates, and assigning distinctive identifiers.</p> <p>The add_relationship function follows this structure:</p> <pre><code>main_obj.add_realtionship(related_object, &lt;side_of_main_obj&gt;_to_&lt;side_of_related_object&gt; (eg. many_to_one), name_of_rel_in_main_obj, name_of_rel_in_related_object\n</code></pre> <p>Potential relationship types encompass:</p> <ul> <li>one_to_one: A one-to-one relationship, present in both the main and related objects.</li> <li>one_to_many: A one-to-many relationship, with the main object as one and the related object as many. This configures the main object to hold a list of related objects. The foreign key is situated in the related object (typically the \"many\" side).</li> <li>many_to_one: The reverse of one_to_many, resulting in the main object as many and the related object as one. The related object is equipped with a list of main objects.</li> <li>many_to_many: A mutual relationship where both objects feature lists of the other. This intricate linkage is managed through an association table in SQLAlchemy.</li> </ul>"},{"location":"#commence-warp-drive","title":"Commence Warp Drive:","text":"<pre><code># Set coordinates \u2013 AppObjects ready for warp\nproject = AppProject(\"galactic_app\", planet, starship, alien, gadget)\n\n# Engage the ProjectCreator, the command bridge of coding\ncreator = ProjectCreator(project, project_dir=\".\")\ncreator.create_project()  # Or use creator.update_project() for warp upgrades\n</code></pre>"},{"location":"#explore-new-discovery","title":"Explore New Discovery:","text":"<p>In your shell go to the folder where your code was generated (folder \"galactic_app\" inside your curent working folder). You need to run startup script which will create virutal enviroment, install requirments, refactor code with black and ruff, run pytest and mypy check, create initial database migration with alembic and run your app.</p> <p>Run the startup script from bash command line (use gitbash or linuxbash).</p> <pre><code>source startup.sh\n</code></pre> <p>You can go on and open your project at http://127.0.0.1:8000/docs. Also check input in your shell to see coverage of the tests and passing of the mypy lint test.</p>"},{"location":"#conclusion","title":"Conclusion","text":"<p>Warp-FastApi: Embark on a voyage of FastAPI exploration, akin to the most exhilarating space odysseys. Bid farewell to repetitive code warp cores and allow Warp-FastApi to be your steadfast warp drive. Set your course now and let your code traverse new frontiers!</p>"},{"location":"AppObject/","title":"AppObject","text":"<p>             Bases: <code>TemplateModel</code></p> <p>A class representing an object in an application.</p> <p>Attributes:</p> Name Type Description <code>attributes</code> <code>list[Attribute]</code> <p>The attributes of the object.</p> <code>relationships</code> <code>list[Relationship | BackpopulatesRelationship]</code> <p>The relationships of the object.</p> <code>back_populates_relationships</code> <code>list[BackpopulatesRelationship]</code> <p>The backpopulates relationships of the object.</p> <code>config</code> <code>AppConfig</code> <p>The configuration of the object.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>class AppObject(TemplateModel):\n\"\"\"\n    A class representing an object in an application.\n    Attributes:\n        attributes (list[Attribute]): The attributes of the object.\n        relationships (list[Relationship | BackpopulatesRelationship]): The relationships of the object.\n        back_populates_relationships (list[BackpopulatesRelationship]): The backpopulates relationships of the object.\n        config (AppConfig): The configuration of the object.\n    \"\"\"\n\n    attributes: list[Attribute]\n    relationships: list[Relationship | BackpopulatesRelationship] = []\n    back_populates_relationships: list[BackpopulatesRelationship] = []\n    config: AppConfig = AppConfig()\n\n    def __init__(\n        self,\n        name: str,\n        *args: Attribute,\n        config: AppConfig = AppConfig(),\n    ):\n\"\"\"\n        Initializes an instance of the `AppObject` class.\n\n        Args:\n            name (str): The name of the object.\n            *args: The attributes of the object.\n            config (AppConfig): The configuration of the object.\n        \"\"\"\n        super().__init__(name=name, attributes=args, config=config)\n\n    def add_relationship(\n        self,\n        obj: AppObject,\n        type: RelationshipType,\n        name: str,\n        back_populates_name: str | None = None,\n        optional: bool = False,\n    ) -&gt; None:\n\"\"\"\n        Adds a relationship to the object.\n        Args:\n            obj (AppObject): The object that is related to this object.\n            type (RelationshipType): The type of the relationship.\n            name (str): The name of the relationship.\n            back_populates_name (str | None): The name of the backpopulates relationship on the related object.\n            optional (bool): Whether the relationship is optional.\n        \"\"\"\n        # TODO: add validation to not have duplicated names in relationships and attributes\n        rel = create_relationship(name, obj, type, self, back_populates_name, optional)\n        self.relationships.append(rel)\n        if isinstance(rel, BackpopulatesRelationship):\n            rel.related_object.back_populates_relationships.append(rel)\n\n    def add_attributes(self, *args: Attribute) -&gt; None:\n\"\"\"\n        Adds attributes to the object.\n\n        Args:\n            *args: The attributes to add.\n        \"\"\"\n        self.attributes += args\n\n    def is_relationship_self(self, rel: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n        Checks if the relationship is a self-relationship.\n\n        Args:\n            rel (Relationship | BackpopulatesRelationship): The relationship to check.\n\n        Returns:\n            bool: Whether the relationship is a self-relationship.\n        \"\"\"\n        self._check_rel(rel)\n        return self.name == rel.related_object.name\n\n    def is_relationship_multiple(self, relationship: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n        Checks if the relationship has multiple instances of the same object.\n\n        Args:\n            relationship (Relationship | BackpopulatesRelationship): The relationship to check.\n\n        Returns:\n            bool: Whether the relationship is multiple.\n        \"\"\"\n        check_list: list[str] = [rel.related_object.name for rel in self.relationships]\n        if self.is_rel_backref(relationship):\n            check_list = [rel.back_populates_object.name for rel in self.back_populates_relationships]\n\n        return check_list.count(relationship.related_object.name) &gt; 1\n\n    def is_relationship_many(self, relationship: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n        Checks if the relationship is many-to-one or many-to-many..\n\n        Args:\n            relationship (Relationship | BackpopulatesRelationship): The relationship to check.\n\n        Returns:\n            bool: Whether the relationship is multiple.\n        \"\"\"\n        self._check_rel(relationship)\n        if relationship in self.relationships:\n            return relationship.relationship_type in (one_to_many, many_to_many)\n        return relationship.relationship_type in (many_to_one, many_to_many)\n\n    def is_rel_backref(self, relationship: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n        Checks if the relationship is backreferances.\n        Args:\n            relationship (Relationship | BackpopulatesRelationship): The relationship to check.\n\n        Returns:\n            bool: Whether the relationship is multiple.\n        \"\"\"\n        self._check_rel(relationship)\n        return relationship in self.back_populates_relationships\n\n    def get_rel_name(self, rel: Relationship | BackpopulatesRelationship) -&gt; str:\n\"\"\"\n        Gets the name of the relationship.\n\n        Args:\n            rel (Relationship | BackpopulatesRelationship): The relationship to get the name of.\n\n        Returns:\n            str: The name of the relationship.\n        \"\"\"\n        if self.is_rel_backref(rel) and isinstance(rel, BackpopulatesRelationship):\n            return rel.back_populates_name\n        return rel.name\n\n    def get_backpopulates_name(self, rel: BackpopulatesRelationship) -&gt; str:\n\"\"\"\n        Gets the name of the backpopulates relationship.\n\n        Args:\n            rel (BackpopulatesRelationship): The relationship to get the name of.\n\n        Returns:\n            str: The name of the relationship.\n        \"\"\"\n        if self.is_rel_backref(rel):\n            return rel.name\n        return rel.back_populates_name\n\n    def get_rel_obj(self, rel: Relationship | BackpopulatesRelationship) -&gt; AppObject:\n\"\"\"\n        Gets the AppObject of the relationship.\n\n        Args:\n            rel (Relationship | BackpopulatesRelationship): The relationship to get the name of.\n\n        Returns:\n            AppObject: AppObject of the relationship.\n        \"\"\"\n        if self.is_rel_backref(rel) and isinstance(rel, BackpopulatesRelationship):\n            return rel.back_populates_object\n        return rel.related_object\n\n    def _check_rel(self, rel: Relationship | BackpopulatesRelationship) -&gt; None:\n\"\"\"\n        Checks if the relationship is associated with the object.\n\n        Args:\n            rel (Relationship | BackpopulatesRelationship): The relationship to check.\n\n        Raises:\n            AttributeError: If the relationship is not associated with the object.\n        \"\"\"\n        if rel not in (self.relationships + self.back_populates_relationships):\n            raise AttributeError('Relationship not associated with object!')\n\n    @property\n    def all_relationships(self) -&gt; list[Relationship | BackpopulatesRelationship]:\n\"\"\"\n        Gets all the relationships of the object.\n\n        Returns:\n            list[Relationship | BackpopulatesRelationship]: The relationships of the object.\n        \"\"\"\n        x: list[Relationship | BackpopulatesRelationship] = list(self.relationships)\n        x.extend(self.back_populates_relationships)\n        return x\n\n    @staticmethod\n    def _class_name(name: str) -&gt; str:\n\"\"\"\n        Converts a name to a class name.\n\n        Args:\n            name (str): The name to convert.\n\n        Returns:\n            str: The class name.\n        \"\"\"\n        splite_names = name.split('_')\n        name = ''.join([split_name.capitalize() for split_name in splite_names])\n        return name\n\n    @property\n    def _plural(self) -&gt; str:\n\"\"\"\n        Gets the plural name of the object.\n\n        Returns:\n            str: The plural name of the object.\n        \"\"\"\n        if self.config.plural:\n            return self.config.plural\n        word = self.name\n        if re.search('[sxz]$', word) or re.search('[^aeioudgkprt]h$', word):\n            return re.sub('$', 'es', word)\n        if re.search('[^aeiou]y$', word):\n            return re.sub('y$', 'ies', word)\n        return word + 's'\n\n    @property\n    def plural_class_name(self) -&gt; str:\n\"\"\"\n        Gets the plural class name of the object.\n\n        Returns:\n            str: The plural class name of the object.\n        \"\"\"\n        if self.config.plural_class_name:\n            return self.config.plural_class_name\n        plural = self._plural\n        return self._class_name(plural)\n\n    @property\n    def class_name(self) -&gt; str:\n\"\"\"\n        Gets the class name of the object.\n\n        Returns:\n            str: The class name of the object.\n        \"\"\"\n        if self.config.class_name:\n            return self.config.class_name\n        return self._class_name(self.name)\n\n    @property\n    def table_name(self) -&gt; str:\n\"\"\"\n        Gets the table name of the object.\n\n        Returns:\n            str: The table name of the object.\n        \"\"\"\n        if self.config.table_name:\n            return self.config.table_name\n        if self.config.plural:\n            return self.config.plural\n        return self._plural\n\n    @property\n    def route_name(self) -&gt; str:\n\"\"\"\n        Gets the route name of the object.\n\n        Returns:\n            str: The route name of the object.\n        \"\"\"\n        if self.config.route_name:\n            return self.config.route_name\n        if self.config.plural:\n            return self.config.plural.replace('_', '-')\n        return self._plural.replace('_', '-')\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.all_relationships","title":"<code>all_relationships: list[Relationship | BackpopulatesRelationship]</code>  <code>property</code>","text":"<p>Gets all the relationships of the object.</p> <p>Returns:</p> Type Description <code>list[Relationship | BackpopulatesRelationship]</code> <p>list[Relationship | BackpopulatesRelationship]: The relationships of the object.</p>"},{"location":"AppObject/#warp_fastapi.main.AppObject.class_name","title":"<code>class_name: str</code>  <code>property</code>","text":"<p>Gets the class name of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The class name of the object.</p>"},{"location":"AppObject/#warp_fastapi.main.AppObject.plural_class_name","title":"<code>plural_class_name: str</code>  <code>property</code>","text":"<p>Gets the plural class name of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The plural class name of the object.</p>"},{"location":"AppObject/#warp_fastapi.main.AppObject.route_name","title":"<code>route_name: str</code>  <code>property</code>","text":"<p>Gets the route name of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The route name of the object.</p>"},{"location":"AppObject/#warp_fastapi.main.AppObject.table_name","title":"<code>table_name: str</code>  <code>property</code>","text":"<p>Gets the table name of the object.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The table name of the object.</p>"},{"location":"AppObject/#warp_fastapi.main.AppObject.__init__","title":"<code>__init__(name, *args, config=AppConfig())</code>","text":"<p>Initializes an instance of the <code>AppObject</code> class.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the object.</p> required <code>*args</code> <code>Attribute</code> <p>The attributes of the object.</p> <code>()</code> <code>config</code> <code>AppConfig</code> <p>The configuration of the object.</p> <code>AppConfig()</code> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    *args: Attribute,\n    config: AppConfig = AppConfig(),\n):\n\"\"\"\n    Initializes an instance of the `AppObject` class.\n\n    Args:\n        name (str): The name of the object.\n        *args: The attributes of the object.\n        config (AppConfig): The configuration of the object.\n    \"\"\"\n    super().__init__(name=name, attributes=args, config=config)\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.add_attributes","title":"<code>add_attributes(*args)</code>","text":"<p>Adds attributes to the object.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Attribute</code> <p>The attributes to add.</p> <code>()</code> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def add_attributes(self, *args: Attribute) -&gt; None:\n\"\"\"\n    Adds attributes to the object.\n\n    Args:\n        *args: The attributes to add.\n    \"\"\"\n    self.attributes += args\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.add_relationship","title":"<code>add_relationship(obj, type, name, back_populates_name=None, optional=False)</code>","text":"<p>Adds a relationship to the object.</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>AppObject</code> <p>The object that is related to this object.</p> required <code>type</code> <code>RelationshipType</code> <p>The type of the relationship.</p> required <code>name</code> <code>str</code> <p>The name of the relationship.</p> required <code>back_populates_name</code> <code>str | None</code> <p>The name of the backpopulates relationship on the related object.</p> <code>None</code> <code>optional</code> <code>bool</code> <p>Whether the relationship is optional.</p> <code>False</code> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def add_relationship(\n    self,\n    obj: AppObject,\n    type: RelationshipType,\n    name: str,\n    back_populates_name: str | None = None,\n    optional: bool = False,\n) -&gt; None:\n\"\"\"\n    Adds a relationship to the object.\n    Args:\n        obj (AppObject): The object that is related to this object.\n        type (RelationshipType): The type of the relationship.\n        name (str): The name of the relationship.\n        back_populates_name (str | None): The name of the backpopulates relationship on the related object.\n        optional (bool): Whether the relationship is optional.\n    \"\"\"\n    # TODO: add validation to not have duplicated names in relationships and attributes\n    rel = create_relationship(name, obj, type, self, back_populates_name, optional)\n    self.relationships.append(rel)\n    if isinstance(rel, BackpopulatesRelationship):\n        rel.related_object.back_populates_relationships.append(rel)\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.get_backpopulates_name","title":"<code>get_backpopulates_name(rel)</code>","text":"<p>Gets the name of the backpopulates relationship.</p> <p>Parameters:</p> Name Type Description Default <code>rel</code> <code>BackpopulatesRelationship</code> <p>The relationship to get the name of.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the relationship.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def get_backpopulates_name(self, rel: BackpopulatesRelationship) -&gt; str:\n\"\"\"\n    Gets the name of the backpopulates relationship.\n\n    Args:\n        rel (BackpopulatesRelationship): The relationship to get the name of.\n\n    Returns:\n        str: The name of the relationship.\n    \"\"\"\n    if self.is_rel_backref(rel):\n        return rel.name\n    return rel.back_populates_name\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.get_rel_name","title":"<code>get_rel_name(rel)</code>","text":"<p>Gets the name of the relationship.</p> <p>Parameters:</p> Name Type Description Default <code>rel</code> <code>Relationship | BackpopulatesRelationship</code> <p>The relationship to get the name of.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the relationship.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def get_rel_name(self, rel: Relationship | BackpopulatesRelationship) -&gt; str:\n\"\"\"\n    Gets the name of the relationship.\n\n    Args:\n        rel (Relationship | BackpopulatesRelationship): The relationship to get the name of.\n\n    Returns:\n        str: The name of the relationship.\n    \"\"\"\n    if self.is_rel_backref(rel) and isinstance(rel, BackpopulatesRelationship):\n        return rel.back_populates_name\n    return rel.name\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.get_rel_obj","title":"<code>get_rel_obj(rel)</code>","text":"<p>Gets the AppObject of the relationship.</p> <p>Parameters:</p> Name Type Description Default <code>rel</code> <code>Relationship | BackpopulatesRelationship</code> <p>The relationship to get the name of.</p> required <p>Returns:</p> Name Type Description <code>AppObject</code> <code>AppObject</code> <p>AppObject of the relationship.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def get_rel_obj(self, rel: Relationship | BackpopulatesRelationship) -&gt; AppObject:\n\"\"\"\n    Gets the AppObject of the relationship.\n\n    Args:\n        rel (Relationship | BackpopulatesRelationship): The relationship to get the name of.\n\n    Returns:\n        AppObject: AppObject of the relationship.\n    \"\"\"\n    if self.is_rel_backref(rel) and isinstance(rel, BackpopulatesRelationship):\n        return rel.back_populates_object\n    return rel.related_object\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.is_rel_backref","title":"<code>is_rel_backref(relationship)</code>","text":"<p>Checks if the relationship is backreferances.</p> <p>Parameters:</p> Name Type Description Default <code>relationship</code> <code>Relationship | BackpopulatesRelationship</code> <p>The relationship to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the relationship is multiple.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def is_rel_backref(self, relationship: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n    Checks if the relationship is backreferances.\n    Args:\n        relationship (Relationship | BackpopulatesRelationship): The relationship to check.\n\n    Returns:\n        bool: Whether the relationship is multiple.\n    \"\"\"\n    self._check_rel(relationship)\n    return relationship in self.back_populates_relationships\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.is_relationship_many","title":"<code>is_relationship_many(relationship)</code>","text":"<p>Checks if the relationship is many-to-one or many-to-many..</p> <p>Parameters:</p> Name Type Description Default <code>relationship</code> <code>Relationship | BackpopulatesRelationship</code> <p>The relationship to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the relationship is multiple.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def is_relationship_many(self, relationship: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n    Checks if the relationship is many-to-one or many-to-many..\n\n    Args:\n        relationship (Relationship | BackpopulatesRelationship): The relationship to check.\n\n    Returns:\n        bool: Whether the relationship is multiple.\n    \"\"\"\n    self._check_rel(relationship)\n    if relationship in self.relationships:\n        return relationship.relationship_type in (one_to_many, many_to_many)\n    return relationship.relationship_type in (many_to_one, many_to_many)\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.is_relationship_multiple","title":"<code>is_relationship_multiple(relationship)</code>","text":"<p>Checks if the relationship has multiple instances of the same object.</p> <p>Parameters:</p> Name Type Description Default <code>relationship</code> <code>Relationship | BackpopulatesRelationship</code> <p>The relationship to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the relationship is multiple.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def is_relationship_multiple(self, relationship: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n    Checks if the relationship has multiple instances of the same object.\n\n    Args:\n        relationship (Relationship | BackpopulatesRelationship): The relationship to check.\n\n    Returns:\n        bool: Whether the relationship is multiple.\n    \"\"\"\n    check_list: list[str] = [rel.related_object.name for rel in self.relationships]\n    if self.is_rel_backref(relationship):\n        check_list = [rel.back_populates_object.name for rel in self.back_populates_relationships]\n\n    return check_list.count(relationship.related_object.name) &gt; 1\n</code></pre>"},{"location":"AppObject/#warp_fastapi.main.AppObject.is_relationship_self","title":"<code>is_relationship_self(rel)</code>","text":"<p>Checks if the relationship is a self-relationship.</p> <p>Parameters:</p> Name Type Description Default <code>rel</code> <code>Relationship | BackpopulatesRelationship</code> <p>The relationship to check.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>Whether the relationship is a self-relationship.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def is_relationship_self(self, rel: Relationship | BackpopulatesRelationship) -&gt; bool:\n\"\"\"\n    Checks if the relationship is a self-relationship.\n\n    Args:\n        rel (Relationship | BackpopulatesRelationship): The relationship to check.\n\n    Returns:\n        bool: Whether the relationship is a self-relationship.\n    \"\"\"\n    self._check_rel(rel)\n    return self.name == rel.related_object.name\n</code></pre>"},{"location":"AppProject/","title":"AppProject","text":"<p>             Bases: <code>TemplateModel</code></p> <p>A class that represents an app project.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>str: The name of the model. Name should be snake_case. From TemplateModel</p> <code>app_objects</code> <code>list[AppObject]</code> <p>list[AppObject]: The list of app objects in the project.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>class AppProject(TemplateModel):\n\"\"\"\n    A class that represents an app project.\n\n    Attributes:\n        name: str: The name of the model. Name should be snake_case. From TemplateModel\n        app_objects: list[AppObject]: The list of app objects in the project.\n    \"\"\"\n\n    app_objects: list[AppObject]\n\n    def __init__(self, name: str, *args: AppObject):\n\"\"\"\n        Initialize the project with the given name and app objects.\n\n        Args:\n            name: The name of the project.\n            args: A list of app objects for the project.\n        \"\"\"\n        super().__init__(name=name, app_objects=args)\n</code></pre>"},{"location":"AppProject/#warp_fastapi.main.AppProject.__init__","title":"<code>__init__(name, *args)</code>","text":"<p>Initialize the project with the given name and app objects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the project.</p> required <code>args</code> <code>AppObject</code> <p>A list of app objects for the project.</p> <code>()</code> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def __init__(self, name: str, *args: AppObject):\n\"\"\"\n    Initialize the project with the given name and app objects.\n\n    Args:\n        name: The name of the project.\n        args: A list of app objects for the project.\n    \"\"\"\n    super().__init__(name=name, app_objects=args)\n</code></pre>"},{"location":"Attribute/","title":"Attribute","text":"<p>             Bases: <code>TemplateModel</code></p> <p>A class that represents an attribute in a template model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <p>str: The name of the model. Name should be snake_case. From TemplateModel</p> <code>type</code> <code>DataType</code> <p>DataType: The type of the attribute.</p> <code>default</code> <code>Any | None</code> <p>Any|None: The default value of the attribute. Defaults to None.</p> <code>unique</code> <code>bool</code> <p>bool: Whether or not the attribute is unique. Defaults to False.</p> <code>optional</code> <code>bool</code> <p>bool: Whether or not the attribute is optional. Defaults to False.</p> <code>validation</code> <code>list[Callable[[Any], Any]]</code> <p>list[Callable[[Any],Any]]: Not implemented.</p> <code>in_schema</code> <code>list[SchemaType]</code> <p>list[SchemaType]: Not implemented.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>class Attribute(TemplateModel):\n\"\"\"\n    A class that represents an attribute in a template model.\n\n    Attributes:\n        name: str: The name of the model. Name should be snake_case. From TemplateModel\n        type: DataType: The type of the attribute.\n        default: Any|None: The default value of the attribute. Defaults to None.\n        unique: bool: Whether or not the attribute is unique. Defaults to False.\n        optional: bool: Whether or not the attribute is optional. Defaults to False.\n        validation: list[Callable[[Any],Any]]: Not implemented.\n        in_schema: list[SchemaType]: Not implemented.\n    \"\"\"\n\n    type: DataType\n    default: Any | None = None\n    unique: bool = False\n    optional: bool = False\n    validation: list[Callable[[Any], Any]] = []\n    in_schema: list[SchemaType] = all_schemas\n\n    # TODO: add validation for type and default value\n    def __init__(\n        self,\n        name: str,\n        type: DataType,\n        default: Any = None,\n        unique: bool = False,\n        optional: bool = False,\n        validation_rules: list[Callable[[Any], Any]] = [],\n    ) -&gt; None:\n\"\"\"\n        Initializes the attribute with the given arguments.\n\n        Args:\n            name: str: The name of the attribute.\n            type: DataType: The type of the attribute.\n            default: Any: The default value of the attribute. Defaults to None.\n            unique: bool: Whether or not the attribute is unique. Defaults to False.\n            optional: bool: Whether or not the attribute is optional. Defaults to False.\n            validation_rules: list[Callable[[Any],Any]]: Not implemented.\n        \"\"\"\n        super().__init__(\n            name=name,\n            type=type,\n            default=default,\n            unique=unique,\n            optional=optional,\n            validation_rules=validation_rules,\n        )\n</code></pre>"},{"location":"Attribute/#warp_fastapi.main.Attribute.__init__","title":"<code>__init__(name, type, default=None, unique=False, optional=False, validation_rules=[])</code>","text":"<p>Initializes the attribute with the given arguments.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>str: The name of the attribute.</p> required <code>type</code> <code>DataType</code> <p>DataType: The type of the attribute.</p> required <code>default</code> <code>Any</code> <p>Any: The default value of the attribute. Defaults to None.</p> <code>None</code> <code>unique</code> <code>bool</code> <p>bool: Whether or not the attribute is unique. Defaults to False.</p> <code>False</code> <code>optional</code> <code>bool</code> <p>bool: Whether or not the attribute is optional. Defaults to False.</p> <code>False</code> <code>validation_rules</code> <code>list[Callable[[Any], Any]]</code> <p>list[Callable[[Any],Any]]: Not implemented.</p> <code>[]</code> Source code in <code>warp_fastapi\\main.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    type: DataType,\n    default: Any = None,\n    unique: bool = False,\n    optional: bool = False,\n    validation_rules: list[Callable[[Any], Any]] = [],\n) -&gt; None:\n\"\"\"\n    Initializes the attribute with the given arguments.\n\n    Args:\n        name: str: The name of the attribute.\n        type: DataType: The type of the attribute.\n        default: Any: The default value of the attribute. Defaults to None.\n        unique: bool: Whether or not the attribute is unique. Defaults to False.\n        optional: bool: Whether or not the attribute is optional. Defaults to False.\n        validation_rules: list[Callable[[Any],Any]]: Not implemented.\n    \"\"\"\n    super().__init__(\n        name=name,\n        type=type,\n        default=default,\n        unique=unique,\n        optional=optional,\n        validation_rules=validation_rules,\n    )\n</code></pre>"},{"location":"Relationship/","title":"Relationship","text":"<p>             Bases: <code>TemplateModel</code></p> <p>A class representing a relationship between two objects.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the relationship.</p> required <code>obj</code> <code>AppObject</code> <p>The object that this relationship is associated with.</p> required <code>type</code> <code>RelationshipType</code> <p>The type of relationship.</p> required <code>optional</code> <code>bool</code> <p>Whether the relationship is optional. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>RelationshipException</code> <p>If the relationship type is <code>many_to_many</code>.</p> Source code in <code>warp_fastapi\\main.py</code> <pre><code>class Relationship(TemplateModel):\n\"\"\"\n    A class representing a relationship between two objects.\n\n    Args:\n        name (str): The name of the relationship.\n        obj (AppObject): The object that this relationship is associated with.\n        type (RelationshipType): The type of relationship.\n        optional (bool, optional): Whether the relationship is optional. Defaults to False.\n\n    Raises:\n        RelationshipException: If the relationship type is `many_to_many`.\n    \"\"\"\n\n    related_object: AppObject\n    relationship_type: RelationshipType\n    optional: bool = False\n\n    def __init__(\n        self,\n        name: str,\n        obj: AppObject,\n        type: RelationshipType,\n        optional: bool = False,\n    ) -&gt; None:\n        if type == many_to_many:\n            raise RelationshipException(RelMsgErr.MANY_MANY_ERR)\n        super().__init__(\n            name=name,\n            related_object=obj,\n            relationship_type=type,\n            optional=optional,\n        )\n</code></pre>"},{"location":"SQL_Types/","title":"SQL tyes","text":""},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.bigint_type","title":"<code>bigint_type = DataType(int, BigInteger)</code>  <code>module-attribute</code>","text":"<p>The <code>bigint_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>int</code> Python type and the <code>BigInteger</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>bigint_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.bool_type","title":"<code>bool_type = DataType(bool, Boolean)</code>  <code>module-attribute</code>","text":"<p>The <code>bool_type</code> variable is a shortcut for creating a <code>DataType</code>  that represents the <code>bool</code> Python type and the <code>Boolean</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>bool_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.date_only_type","title":"<code>date_only_type = DataType(date, Date)</code>  <code>module-attribute</code>","text":"<p>The <code>date_only_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>date</code> Python type and the <code>Date</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>date_only_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.date_time_type","title":"<code>date_time_type = DataType(datetime, DateTime)</code>  <code>module-attribute</code>","text":"<p>The <code>date_time_type</code> variable is a shortcut for creating a <code>DataType</code>  that represents the <code>datetime</code> Python type and the <code>DateTime</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>date_time_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.decimal_type","title":"<code>decimal_type = DataType(Decimal, Numeric)</code>  <code>module-attribute</code>","text":"<p>The <code>decimal_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>Decimal</code> Python type and the <code>Numeric</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>decimal_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.float_type","title":"<code>float_type = DataType(float, Float)</code>  <code>module-attribute</code>","text":"<p>The <code>float_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>float</code> Python type and the <code>Float</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>float_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.int_type","title":"<code>int_type = DataType(int, Integer)</code>  <code>module-attribute</code>","text":"<p>The <code>int_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>int</code> Python type and the <code>Integer</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>int_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.string_type","title":"<code>string_type = DataType(str, String)</code>  <code>module-attribute</code>","text":"<p>The <code>string_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>str</code> Python type and the <code>String</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>string_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.text_type","title":"<code>text_type = DataType(str, Text)</code>  <code>module-attribute</code>","text":"<p>The <code>text_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>str</code> Python type and the <code>Text</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>text_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.time_type","title":"<code>time_type = DataType(time, Time)</code>  <code>module-attribute</code>","text":"<p>The <code>time_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>time</code> Python type and the <code>Time</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>time_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.timedelta_type","title":"<code>timedelta_type = DataType(timedelta, Interval)</code>  <code>module-attribute</code>","text":"<p>The <code>timedelta_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>timedelta</code> Python type and the <code>Interval</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>timedelta_type</code> variable is set to <code>None</code>.</p>"},{"location":"SQL_Types/#warp_fastapi.sqlalch_types.unicode_type","title":"<code>unicode_type = DataType(str, Unicode)</code>  <code>module-attribute</code>","text":"<p>The <code>unicode_type</code> variable is a shortcut for creating a <code>DataType</code> object that represents the <code>str</code> Python type and the <code>Unicode</code> database type.</p> <p>The <code>pydantic_type</code> attribute of the <code>unicode_type</code> variable is set to <code>None</code>.</p>"},{"location":"Types/","title":"Types","text":"<p>             Bases: <code>BaseModel</code></p> <p>DataType object used in fastapiez</p> <p>Attributes:</p> Name Type Description <code>python_type</code> <code>str</code> <p>The Python type of the data type.</p> <code>python_module</code> <code>str</code> <p>The module that the Python type belongs to.</p> <code>db_type</code> <code>str</code> <p>The database type of the data type.</p> <code>db_module</code> <code>str</code> <p>The module that the database type belongs to.</p> <code>pydantic_type</code> <code>str</code> <p>The Pydantic type of the data type.</p> <p>Methods:</p> Name Description <code>add_pydantic_type</code> <p>Adds the given Pydantic type to the data type.</p> Source code in <code>warp_fastapi\\types.py</code> <pre><code>class DataType(BaseModel):\n\"\"\"\n    DataType object used in fastapiez\n\n    Attributes:\n        python_type (str): The Python type of the data type.\n        python_module (str): The module that the Python type belongs to.\n        db_type (str): The database type of the data type.\n        db_module (str): The module that the database type belongs to.\n        pydantic_type (str): The Pydantic type of the data type.\n\n    Methods:\n        add_pydantic_type(t): Adds the given Pydantic type to the data type.\n    \"\"\"\n\n    python_type: str\n    python_module: str\n    db_type: str\n    db_module: str\n    pydantic_type: str | None = None\n\n    def __init__(self, python_type: type, db_type: type, pydantic_type: type | None = None):\n\"\"\"\n        Initializes a new `DataType` instance.\n        Args:\n            python_type (type): The Python type of the data type.\n            db_type (type): The database type of the data type.\n            pydantic_type (type, optional): The Pydantic type of the data type. Defaults to None.\n        \"\"\"\n        super().__init__(\n            python_type=python_type.__name__,\n            python_module=python_type.__module__,\n            db_type=db_type.__name__,\n            db_module=db_type.__module__,\n        )\n        if pydantic_type:\n            self.add_pydantic_type(pydantic_type)\n\n    def add_pydantic_type(self, t: type) -&gt; None:\n\"\"\"\n        Adds the given Pydantic type to the data type.\n\n        Args:\n            t (type): The Pydantic type to add.\n        \"\"\"\n        self.pydantic_type = t.__name__\n</code></pre>"},{"location":"Types/#warp_fastapi.types.DataType.__init__","title":"<code>__init__(python_type, db_type, pydantic_type=None)</code>","text":"<p>Initializes a new <code>DataType</code> instance.</p> <p>Parameters:</p> Name Type Description Default <code>python_type</code> <code>type</code> <p>The Python type of the data type.</p> required <code>db_type</code> <code>type</code> <p>The database type of the data type.</p> required <code>pydantic_type</code> <code>type</code> <p>The Pydantic type of the data type. Defaults to None.</p> <code>None</code> Source code in <code>warp_fastapi\\types.py</code> <pre><code>def __init__(self, python_type: type, db_type: type, pydantic_type: type | None = None):\n\"\"\"\n    Initializes a new `DataType` instance.\n    Args:\n        python_type (type): The Python type of the data type.\n        db_type (type): The database type of the data type.\n        pydantic_type (type, optional): The Pydantic type of the data type. Defaults to None.\n    \"\"\"\n    super().__init__(\n        python_type=python_type.__name__,\n        python_module=python_type.__module__,\n        db_type=db_type.__name__,\n        db_module=db_type.__module__,\n    )\n    if pydantic_type:\n        self.add_pydantic_type(pydantic_type)\n</code></pre>"},{"location":"Types/#warp_fastapi.types.DataType.add_pydantic_type","title":"<code>add_pydantic_type(t)</code>","text":"<p>Adds the given Pydantic type to the data type.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>type</code> <p>The Pydantic type to add.</p> required Source code in <code>warp_fastapi\\types.py</code> <pre><code>def add_pydantic_type(self, t: type) -&gt; None:\n\"\"\"\n    Adds the given Pydantic type to the data type.\n\n    Args:\n        t (type): The Pydantic type to add.\n    \"\"\"\n    self.pydantic_type = t.__name__\n</code></pre>"},{"location":"licences/","title":"Licence","text":"<p>MIT License</p> <p>Copyright (c) 2023 frenki123</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"todo/","title":"TODO:","text":"<p>Future implementations:</p> <ul> <li>Create Github CI/CD</li> <li>Add mypy </li> <li>Add automatic docker file creation</li> <li>Automatically run project from docker</li> <li>Add support for postgress, mysql with docker</li> <li>Add automatic git creation</li> <li>Add automatic github deployment</li> <li>Add automatic Azure/AWS/GoogleCloud deployment with docker</li> <li>Add \"create function only route\"</li> <li>Add class parser to create AppObjects, Attributes and Relationships</li> <li>Add standard attributes</li> <li>Add support for non DB objects</li> <li>Add support for service/logic functions</li> <li>Change DataType -&gt; if in <code>__init__</code> pydantic type is None, then use python type</li> <li>Add support for Fields in Attributes</li> <li>Add search with multiple parametars and operators</li> <li>Automatic SDK creation</li> <li>Add CLI support with Typer</li> </ul>"}]}